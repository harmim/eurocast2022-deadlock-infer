%-----------------------------------------------------------------------------
% Eurocast 2022 on Deadlocks
%-----------------------------------------------------------------------------

\documentclass[runningheads]{llncs}

% Packages
\usepackage{pbox}
\usepackage{graphicx}
\usepackage{times}
\usepackage{xcolor}
\usepackage{amsmath, amssymb}
\usepackage{dirtytalk}
\usepackage{wrapfig}
\usepackage{listings}

% Useful commands (todo, remark, ...)
\newcommand{\todo}[1]{\textcolor{blue}{[TODO: #1]}}
\newcommand{\rem}[1]{\textcolor{blue}{[NOTE: #1]}}
\newcommand{\fixme}[1]{\textcolor{red}{[FIXME: #1]}}

\definecolor{bluekeywords}{rgb}{.13, .13, 1}
\definecolor{greencomments}{rgb}{0, .5, 0}
\definecolor{redstrings}{rgb}{.9, 0, 0}
\lstset{
    basicstyle=\ttfamily,
    numberstyle=\ttfamily\footnotesize,
    keywordstyle=\color{bluekeywords},
    commentstyle=\color{greencomments},
    stringstyle=\color{redstrings},
    tabsize=2,
    escapeinside={<@}{@>},
    columns=fullflexible,
    showstringspaces=false,
    keepspaces=true,
    showspaces=false,
    showtabs=false,
    breaklines=true,
    breakatwhitespace=true,
    numbers=left,
    xleftmargin=2em,
    captionpos=b,
    belowskip=-.8\baselineskip,
    % aboveskip=1\baselineskip,
}
\lstdefinestyle{c}{language=c}

%-----------------------------------------------------------------------------
\begin{document}
%-----------------------------------------------------------------------------

\newcommand{\thetitle}{Static Deadlock Detection in Low-Level C~Code}
\title{\thetitle\thanks{%
    The work was supported by the Czech Science Foundation (the project
    No.~20-07487S) and the Brno Ph.D. Talent Scholarship Programme.%
}}
\titlerunning{\thetitle}

\author{%
  Dominik Harmim \and
  Vladim\'{\i}r Marcin \and
  Lucie Svobodov\'{a} \and
  Tom\'{a}\v{s} Vojnar%
}
\authorrunning{%
    D. Harmim \and
    V. Marcin \and
    L. Svobodov\'{a} \and
    T. Vojnar%
}

\institute{%
    Faculty of Information Technology, Brno University of Technology \\
    Brno, Czech Republic \\
    \email{\{iharmim,vojnar\}@fit.vut.cz}%
}

\maketitle

\begin{abstract}
    We present a~novel \emph{scalable deadlock analyser} (\textsc{L2D2}) that
    works \emph{compositionally} and applies to~\emph{C~code} with
    \emph{low-level unstructured lock manipulation}. We proposed and
    implemented \textsc{L2D2} as a~plugin of the Facebook/Meta \textsc{Infer}
    framework. \textsc{L2D2} runs \emph{along the call tree} of a~given
    program, \emph{starting from its leaves}. Each function is thus analysed
    just once without any knowledge of its possible call contexts. For each
    analysed function, we derive a~summary that contains \emph{lock
    dependencies}. In the end, we compute the transitive closure of
    these dependencies, and we consider found cycles as deadlocks.
    Our experimental evaluation on a~set of C~programs with POSIX threads
    derived from a~Debian GNU/Linux distribution with in total 11.4\,MLoC
    shows that our approach is effective in practice, finding all known
    deadlocks and giving false alarms in less than 4\,\% of the considered
    programs only.
\end{abstract}

%-----------------------------------------------------------------------------
\section{Introduction}
%-----------------------------------------------------------------------------

Nowadays, programs often use \emph{multithreading} to utilise the many
processors of current computers better. However, concurrency does bring not
only speed-ups but also a~much larger space for nasty errors easy to cause
but difficult to find. The reason why finding errors in concurrent programs
is particularly hard is that concurrently running threads may
\emph{interleave} in many different ways, with bugs hiding in just a~few of
them. Such interleavings need not be discovered even by many-times repeated
testing.

Coverage of such rare behaviours can be improved using approaches such
as \emph{systematic testing}~\cite{schedspec12} and \emph{noise-based
testing}~\cite{contestframework03,noise15,anaconda}.
Another way is to use \emph{extrapolating dynamic checkers}, such
as~\cite{fasttrack09,velodrome08}, which can report warnings about possible
errors even if those are not seen in the testing runs, based on spotting
some of their symptoms. Unfortunately, even though such checkers have
proven quite useful in practice, they can, of course, still miss errors.
Moreover, monitoring a~run of large software through such checkers may also
be quite expensive.

On the other hand, approaches based on \emph{model checking}, i.e., exhaustive
state-space exploration, can guarantee the discovery of all potentially
present errors\,---\,either in general or at least up to some bound, which
is usually given in the number of context switches. However, so far, the
scalability of these techniques is not sufficient to handle truly large
industrial code, even when combined with methods such as
\emph{sequentialisation}~\cite{lal-reps-08,lazy-seq-16}, which represents
one of the most scalable approaches in the area.

An alternative to the above approaches, which can scale better than model
checking and can find bugs not found dynamically (though for the price of
potentially missing some errors and/or producing false alarms), is offered
by approaches based on \emph{static analysis}, e.g., in the form of
\emph{abstract interpretation}~\cite{ai77} or
\emph{data-flow analysis}~\cite{dfa73}. The former approach is supported,
e.g., in Facebook/Meta \textsc{Infer}\,---\,an open-source framework for
creating highly scalable, compositional, incremental, and interprocedural
static analysers based on abstract interpretation~\cite{inferNFM15}.
\textsc{Infer} has initially been a~rather specialised tool focused on
\emph{sound verification} of the absence of memory safety violations,
which was first published in the well-known paper~\cite{biabd09}. Once
Facebook/Meta has purchased it, its scope significantly widened and
abandoned the focus on sound analysis only. \textsc{Infer} has grown
considerably, but it is still under active development. It is employed
every day not only in Facebook/Meta itself but also in other companies,
such as Amazon, Microsoft, Mozilla, Spotify, or Uber. Currently,
\textsc{Infer} provides several analysers that check for various types
of bugs, such as buffer overflows, null-dereferencing, or memory leaks.
However, most importantly, \textsc{Infer} is a~\emph{framework} for
building new analysers quickly and easily. As for
\emph{concurrency-related bugs}, \textsc{Infer} provides support for
finding some forms of \emph{data races} and \emph{deadlocks}, but it is
limited to \emph{high-level} Java and C++ programs only and fails for
C~programs, which use a~\emph{lower-level lock
manipulation}~\cite{racerD18,inferCACM19}.

In this paper, we propose a~\emph{deadlock checker} that fits the common
principles of analyses used in \textsc{Infer} and is applicable to
\emph{C~code} with \emph{lower-level lock manipulation}. Our checker is
called \textsc{L2D2} for \say{low-level deadlock detector}.

\paragraph{Structure of the Paper}
The rest of this paper is organised as follows. Section~\ref{sec:relwork}
discusses related work. A~design of the \textsc{L2D2} analyser is
introduced in Section~\ref{sec:l2d2}. The paper then goes on in
Section~\ref{sec:heuristics} to outline several considered heuristics that
increase accuracy of the analysis. This is followed by
Section~\ref{sec:experiments}, which covers the experimental evaluation of
the implemented approach. Finally, the paper is concluded and further
research directions are provided in Section~\ref{sec:con}.

\subsection{Related Work}
\label{sec:relwork}

Nowadays, there is a~number of tools for deadlock detection in
multi-threaded programs. A~common deficiency of a~large number of them
is that they are unsound and/or incomplete, or they are precise, but
their requirements on time and resources are unacceptable when applied to
large codebases.

To our knowledge, \textsc{L2D2} is the only available \emph{compositional
static deadlock analyser} for \emph{low-level code}. Nevertheless, in this
section, we briefly compare our contribution to related work, first, on
dynamic tools, and second, on static tools.

\subsubsection{Dynamic Analyses}

Dynamic analysers work with \emph{program traces}. They require the whole
program as well as appropriate \emph{test input data}, and their scalability
is often very limited. These techniques tend to focus on completeness
(however, this does not need to hold for \emph{extrapolation based approaches}
such as the below-mentioned \textsc{GoodLock}) but cannot be sound.

\textsc{GoodLock}~\cite{goodlock00} is a~well-known dynamic analysis for
Java programs implemented in Java PathFinder (JPF)~\cite{jpf00}. This
approach uses \emph{deadlock prediction} to detect a~deadlock. It makes
predictions about an exponential number of permutations of single
execution history. Essentially, it monitors the lock acquisition history
by creating a~\emph{dynamic lock-order graph}, followed by checking the
graph for the existence of deadlock candidates by searching for cycles
in it. A~drawback of this approach is that it may produce a~high rate
of false positives.

\textsc{AirLock}~\cite{airlock20} is one of the state-of-the-art dynamic
deadlock analysers. It adopts and improves the basic approach from
\textsc{GoodLock} by applying various optimisations to the extracted
lock-order graph. Moreover, \textsc{AirLock} operating on-the-fly,
running a~polynomial-time algorithm on the lock graph to eliminate parts
without cycles before running the higher-cost algorithm to detect
actual lock cycles.

\subsubsection{Static Analyses}

Static deadlock detectors can often handle much larger systems and may
produce sound results. However, static techniques are generally incomplete,
so soundness is sometimes dropped to minimise the number of false alarms.
Most of the existing deadlock analysers are interprocedural, top-down,
context-sensitive, and non-compositional. Although, this is not the case
of \textsc{L2D2} and the below-mentioned \textsc{Starvation} checker, which
are both \emph{bottom-up}, \emph{context-insensitive}, and
\emph{compositional}. Below are listed three analyses in some aspects close
to \textsc{L2D2}; indeed, some of the approaches used in \textsc{L2D2} are
inspired by them.

\textsc{RacerX}~\cite{racerX03} is a~flow-sensitive (based on
\emph{data-flow analysis}) and context-sensitive analysis for C~programs
building a~\emph{static lock-order graph} by computing so-called
\emph{locksets}, i.e., sets of currently held locks, and reporting
possible deadlocks in case of cycles in it. It does not use a~pointer
analysis, and many heuristics are employed to reduce false-positive
reports. This approach, however, still produces many false alarms due to
the used approximations, and its context sensitivity reduces the scalability.

The deadlock analyser implemented within the \textsc{CProver}
framework~\cite{kroening16} targeting C~code with POSIX threads uses
a~combination of multiple analyses to create a~sound analysis. The analysis
is context-sensitive and is based on \emph{abstract interpretation}. It also
builds a~lock-order graph and searches for cycles to detect deadlocks. The
most significant limitation of this approach is the pointer analysis used,
which takes most of the analysis time. An experimental comparison with this
tool is given in Section~\ref{sec:experiments}.

\textsc{Starvation}~\cite{deadlock-nikos21} is one of the most successful
state-of-the-art deadlock analysers. It is implemented in the
\textsc{Infer} framework; therefore, it is bottom-up, context-insensitive,
compositional, and abstract interpretation based. As a~matter of fact, to
our best knowledge, it is the only existing deadlock detector that works
compositionally. It detects deadlocks by deriving lock dependencies for each
function and checking whether some other function uses the locks in inverse
order. It is thus similar to \textsc{L2D2}, but \textsc{Starvation} is
limited to \emph{high-level} Java and C++ programs with \emph{balanced
locks} only. Moreover, it implements many heuristics explicitly tailored
for Android Java applications.

%-----------------------------------------------------------------------------
\section{Static Deadlock Detection in Low-Level Concurrent C~Code}
\label{sec:l2d2}
%-----------------------------------------------------------------------------

This section presents the design of the \textsc{L2D2} analyser. First, we
sketch out the basic ideas of the analysis. Further, we introduce the
algorithm of the analyser in more detail. In the end, we show an algorithm
for reporting deadlocks.

As already mentioned, \textsc{L2D2} is designed to work
\emph{compositionally}\footnote{\emph{Compositionality} allows us to
concentrate only on \emph{modified files} and their dependants. A~summary of
a~function call depends only on the current state of the caller, which can
be computed in advance. This means that\,---\,when analysing a~code
revision\,---\,we do not need to re-analyse the unchanged functions in the
program (i.e. the vast majority).} and be applied to \emph{C~code} with
\emph{low-level unstructured lock manipulation}. For scalability reasons,
\textsc{L2D2} does not run the analysis along the \emph{Control-Flow Graph
(CFG)} as it is done in classical analyses based on the concepts, e.g.,
from~\cite{dfagr95}. Instead, \textsc{L2D2} performs the analysis of
a~program \emph{function-by-function along the call tree}, \emph{starting
from its leaves} (as typical for the \textsc{Infer} framework). Therefore,
each function is analysed just once without any knowledge of its possible
call contexts. For each analysed function, we derive a~\emph{summary}
that consists of a~\emph{pre-condition} and \emph{post-condition}. The
summaries are then used when analysing functions higher up in the call
hierarchy. More details on how the summaries look and how they are
computed will be given in Section~\ref{sec:summaries}.

We use \emph{syntactic access paths}~\cite{ap15} to represent lock objects.
This mechanism is already built in the \textsc{Infer} framework. The access
paths represent heap locations via the paths used to access them. Then,
\textsc{L2D2} does not have to perform a~classical \emph{alias analysis},
i.e., a~precise analysis for saying whether arbitrary pairs of accesses to
lock objects may alias (such an analysis is considered too
expensive\,---\,no such sufficiently precise analysis works compositionally
and at scale). According to the authors of~\cite{racerD18}, the access paths'
syntactic equality is a~reasonably efficient way to say (in an
under-approximate fashion) that heap accesses touch the same address. They
used this mechanism in \textsc{RacerD}~\cite{racerD18} to detect many data
races in real-world programs.

% \newpage

% \begin{wrapfigure}{r}{.6 \textwidth}
% \begin{lstlisting}[
%     style=c, label={list:basicEx}, caption={Lorem ipsum dolor sit amet}
% ]
% void invoke(char *method) {
%   <@\texttt{\ldots}@>
%   if (server.<@\textbf{is\_registered}@>()) {
%     server.<@\textbf{invoke}@>(method);
%   }
%   <@\texttt{\ldots}@>
% }
% \end{lstlisting}
% \end{wrapfigure}
% Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed faucibus gravida est a dictum. Aliquam nisi libero, posuere sit amet tincidunt quis, dictum a tortor. Nullam varius elit et quam maximus fermentum. Fusce in arcu a odio condimentum hendrerit. Nunc a orci et sem aliquet blandit quis at orci. Ut id est augue. Vestibulum cursus risus quis turpis pellentesque pretium. Nullam convallis purus et lectus convallis volutpat. Aliquam tristique quam eu elit tempus, in dapibus metus congue. Praesent nisl purus, sollicitudin vel elementum vitae, varius sed tellus. Vivamus in convallis nisi. Phasellus erat leo, sodales ac erat quis, suscipit facilisis felis. Ut et tortor malesuada, placerat tellus id, euismod nisi.

% % Intuitively, the pre-condition states what states of locks the function
% % expects from its callers, and the post-condition reflects the effect of the
% % function on the locks.
% %
% % More precisely,
% %
% Intuitively, the pre-condition of a~function states which locks are
% \emph{expected to be locked or unlocked} upon a~call of the function to avoid
% possible double-locking or unlocking, resp.
% %
% The post-condition contains information about which locks \emph{may be locked
% or unlocked} at the exit of the function.
% %
% Next, the summary contains so-called \emph{lock dependencies} in the form of
% pairs of locks $ (l_1, l_2) $ where locking of~$ l_2 $ was seen while~$ l_1 $
% was locked.
% %
% At the end of the analysis, detecting cycles in the lock dependencies is used
% to detect possible deadlocks.
% %
% Finally, the summary also contains information on which \emph{locks may be
% locked and then again unlocked} within the given function, which is needed for
% detecting lock dependencies with such locks in functions higher up in the call
% hierarchy.

\subsection{Computing Function Summaries}
\label{sec:summaries}

\todo{\ldots}

\subsection{Reporting Deadlocks}

\todo{\ldots}

%-----------------------------------------------------------------------------
\section{Increasing Analysis Accuracy}
\label{sec:heuristics}
%-----------------------------------------------------------------------------

\todo{\ldots}

% L2D2 further implements several heuristics intended to decrease the number
% of possible false alarms.
% %
% For instance, since double-locking/unlocking errors are quite rare, their
% detection may instead be used as an indicator that the analysis is
% over-approximating too much, and it may reset (some of) the working sets.
% %
% An example of another heuristic used in L2D2 is the detection of so-called
% \emph{gate locks}, i.e., locks guarding other locks (upon which deadlocks on
% the nested locks are not reported).

%-----------------------------------------------------------------------------
\section{Experimental Evaluation}
\label{sec:experiments}
%-----------------------------------------------------------------------------

\todo{\ldots}
\cite{kroening16}

% Within our experimental evaluation of L2D2, we have applied it on a~set of
% 1,002 C~programs with POSIX threads derived from a~Debian GNU/Linux
% distribution, originally prepared for evaluating the static deadlock analyser
% based on the~CProver framework proposed in~\cite{kroening16}.
% %
% The~benchmark consists of 11.4\,MLoC.
% %
% Eight of the programs contain a~known deadlock.
% %
% Like CProver, L2D2 was able to detect all the deadlocks.
% %
% On the remaining 994 programs, it produced 39 false alarms (78 of the programs
% failed to compile since the Infer's front-end does not support some of the
% constructions used).
% %
% We find this very encouraging, considering that the CProver's deadlock
% detector produced 114 false alarms, 453 timeouts (w.r.t. our 30-minute time
% limit), and ran out of the available 24\,GB of memory in 135 cases.
% %
% Altogether, L2D2 consumed less than~1\,\% of the time taken by CProver.

%-----------------------------------------------------------------------------
\section{Conclusions and Future Work}
\label{sec:con}
%-----------------------------------------------------------------------------

\todo{\ldots}

%-----------------------------------------------------------------------------
% Bibliography
%-----------------------------------------------------------------------------

\bibliographystyle{abbrv}
\bibliography{bibliography}

%-----------------------------------------------------------------------------
\end{document}
%-----------------------------------------------------------------------------
