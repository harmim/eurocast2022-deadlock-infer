%-----------------------------------------------------------------------------
% Eurocast 2022 on Deadlocks -- extended abstract
%-----------------------------------------------------------------------------

\documentclass[runningheads]{llncs}

% Packages
\usepackage{pbox}
\usepackage{times}
\usepackage{color}

% Page style
\pagestyle{plain}

% Section counter (number subsubsections)
\setcounter{tocdepth}{3}

% Useful commands (todo, remark, ...)
\newcommand{\todo}[1]{\textcolor{blue}{[TODO: #1]}}
\newcommand{\rem}[1]{\textcolor{blue}{[NOTE: #1]}}
\newcommand{\fixme}[1]{\textcolor{red}{[FIXME: #1]}}

%-----------------------------------------------------------------------------
\begin{document}
%-----------------------------------------------------------------------------

\mainmatter

\newcommand{\thetitle}{Static Deadlock Detection in Low-Level C Code}

\title{\thetitle\vspace*{-3mm}}

\titlerunning{\thetitle}

\author{
  Dominik Harmim \and
  Vladim\'{\i}r Marcin \and
  Lucie Svobodov\'{a} \and
  Tom\'{a}\v{s} Vojnar
}

\institute{
  FIT, Brno University of Technology, Czech Republic
  %% \\
  %% \email{\{iharmim,vojnar\}@fit.vut.cz}
}

\maketitle

%-----------------------------------------------------------------------------
\vspace*{-4mm}\section{Introduction}\vspace*{-1.5mm}
%-----------------------------------------------------------------------------

Bugs have been present in computer programs ever since the inception of the
programming discipline.
%
Unfortunately, they are often hidden in unexpected places, and they can lead to
unexpected behaviour, which may cause significant damage.
%
This holds in a particularly severe way for \emph{concurrent programs}.
%
At the same time, multiple threads of control are nowadays commonly used to help
reduce latency, increase throughput, and better utilise the many processors of
current computers.

Concurrent programs are particularly hard for traditional testing due to their
concurrently running threads may interleave in many different ways with bugs
hiding in just a few of them.
%
Such rare interleavings need not be discovered even by many-times repeated
testing.
%
The coverage of such behaviours can be improved by approaches such as
\emph{systematic testing} \cite{schedspec12} and \emph{noise-based testing}
\cite{contestframework03,anaconda}.
%
Another way is the use of \emph{extrapolating dynamic checkers}, such as
\cite{atomsetser08,velodrome08,realdeadlock09,fasttrack09}, which can report
warnings about possible errors even if those are not seen in the testing runs,
based on spotting some symptoms of the errors.
%
Unfortunately, even though such checkers have proven quite useful in practice,
they can of course still miss errors.
%
Moreover, monitoring a run of large software through such checkers may also be
quite expensive).

On the other hand, approaches based on \emph{model checking} can guarantee
discovery of all potentially present errors---either in general or at least up
to some bound, which is usually given in the number of context switches.
%
The scalability of these techniques is, however, so far not sufficient to handle
truly large industrial code even when using \emph{bounded model checking} and
\emph{sequentialisation} \cite{lal-reps-08,abou-seq-11,lazy-seq-16}, which
represent the probably most scalable, currently known approaches in the area.
%
Light-weight \emph{static analysis}, such as \cite{racerx03}, can be much more
scalable but can produce many false alarms.
%
A~better compromise between scalability and precision can be achieved through
\emph{abstract interpretation} or \emph{data-flow analysis}.
%
Recently, a~suite of new approaches based on abstract interpretation applied in
a modular way by computing \emph{function summaries} bottom-up over a call tree
have appeared in the Facebook Infer tool \cite{racerD18,racerD19}.
%
Even more recently, a rather scalable and precise approach based on data-flow
analysis have been proposed for finding data races in programs combining
event-based and lock-based programming \cite{o2}.
%
Approaches of this kind are, however, heavily tuned for specific
concurrency-related problems and specific programming techniques.




Recently, Facebook introduced \emph{Facebook Infer}: an \emph{open-source} tool
for creating \emph{highly scalable}, \emph{compositional}, \emph{incremental},
and \emph{interprocedural} static analysers. Facebook Infer has grown
considerably, but it is still under active development. It is employed every day
not only in Facebook itself but also in other companies, such as Spotify, Uber,
Mozilla, or Amazon. Currently, Facebook Infer provides several analysers that
check for various types of bugs, such as buffer overflows, data races and some
forms of deadlocks and starvation, null-dereferencing, or memory leaks. However,
most importantly, Facebook Infer is a~\emph{framework} for building new
analysers quickly and easily. Unfortunately, the current version of Facebook
Infer still lacks better support for \emph{concurrency bugs}. While it provides
a~reasonably advanced data race analyser, it is limited to Java and C++ programs
only and fails for C~programs, which use a~\emph{lower-level lock manipulation}.
Moreover, the only available checker of \emph{atomicity of call sequences} is
the first version of \emph{Atomer}~\cite{harmimBP} proposed in the bachelor's
thesis of the author.


%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
\enlargethispage{6mm}
%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

%-----------------------------------------------------------------------------
\vspace*{-2mm}\section{Related Work}\vspace*{-1.5mm}
%-----------------------------------------------------------------------------


%-----------------------------------------------------------------------------
\vspace*{-2.5mm}\section{Static Deadlock Detection in Low-Level Concurrent C
Code}\vspace*{-1.5mm}
%-----------------------------------------------------------------------------


%-----------------------------------------------------------------------------
% Acknowledgement
%-----------------------------------------------------------------------------

%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
\enlargethispage{5mm}
%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

\vspace*{2mm}{\fontsize{8}{8}\selectfont \noindent\emph{Acknowledgement.} The
work was supported by ...}\vspace*{-2mm}

%-----------------------------------------------------------------------------
% Bibliography
%-----------------------------------------------------------------------------

\bibliographystyle{abbrv}
\bibliography{bibliography}

%-----------------------------------------------------------------------------
\end{document}
%-----------------------------------------------------------------------------
